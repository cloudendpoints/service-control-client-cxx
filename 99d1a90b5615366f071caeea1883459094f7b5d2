Revision: 99d1a90b5615366f071caeea1883459094f7b5d2
Patch-set: 4
File: src/service_control_client_impl.h

78:7-78:17
Fri Mar 25 17:13:10 2016 +0000
Author: Wencheng Lu <5175@3ccfd165-32a1-3a7c-ba90-d72e43bc4584>
UUID: 5c57aee9_75f7c078
Bytes: 323
I feel shared_ptr is not very readable and track. Do you know if there is any ref/uref class like this one: https://cs.corp.google.com/piper///depot/google3/util/refcount/reference_counted.h

I think we just need do ref/unref to manage pending flush callback, and all these shared_ptr here can be changed back to unique_ptr

78:7-78:17
Fri Mar 25 17:54:05 2016 +0000
Author: Wayne Zhang <5025@3ccfd165-32a1-3a7c-ba90-d72e43bc4584>
Parent: 5c57aee9_75f7c078
UUID: 5c57aee9_15691468
Bytes: 118
shared_ptr is ref_counted.   I don't understand why you want to manually implement shared_ptr with your own ref_count.

78:7-78:17
Fri Mar 25 18:13:53 2016 +0000
Author: Wayne Zhang <5025@3ccfd165-32a1-3a7c-ba90-d72e43bc4584>
Parent: 5c57aee9_15691468
UUID: 5c57aee9_75950063
Bytes: 248
Just read the google3 ref_count class.  If we want to protect client object, it will require users of the object to explicitly call Ref/Unref.  They could not simply call new Obj() and delete.   or use unique_ptr<Client>
I don't think we want that.

78:7-78:17
Fri Mar 25 18:22:54 2016 +0000
Author: Wencheng Lu <5175@3ccfd165-32a1-3a7c-ba90-d72e43bc4584>
Parent: 5c57aee9_75950063
UUID: 5c57aee9_f8f485a9
Bytes: 282
Ref/Unref in my mind is much cleaner than implicit reference counting. Also shared_ptr is an expensive op. see google doc on shared_ptr discussion.

Anyway, could you check if there is refcount class available in opensource, if not, we can revisit this after more performance study.

78:7-78:17
Fri Mar 25 18:26:52 2016 +0000
Author: Martin Maly <5006@3ccfd165-32a1-3a7c-ba90-d72e43bc4584>
Parent: 5c57aee9_f8f485a9
UUID: 5c57aee9_d8398129
Bytes: 458
https://engdoc.corp.google.com/eng/doc/devguide/cpp/cpp11.shtml?cl=head

we've been going by PG3 rules which have been created by Google team after surveying support for C++ language features across broad spectrum of compilers to ensure code portability.

Chemist client may have different requirements but I'd probably rather use standard C++ feature than adding a dependency. If it turns out that the performance cost is prohibitive, we could revisit then?

78:7-78:17
Fri Mar 25 18:38:31 2016 +0000
Author: Wencheng Lu <5175@3ccfd165-32a1-3a7c-ba90-d72e43bc4584>
Parent: 5c57aee9_d8398129
UUID: 5c57aee9_7856d531
Bytes: 302
yes, this doc has the link to when we should use shared_ptr:
https://engdoc.corp.google.com/eng/doc/devguide/cpp/styleguide.shtml?cl=head#Ownership_and_Smart_Pointers

see the "decision" section. If there is a better alternative, why would we choose shared_ptr to sacrifice performance and readability?

78:7-78:17
Fri Mar 25 18:54:36 2016 +0000
Author: Martin Maly <5006@3ccfd165-32a1-3a7c-ba90-d72e43bc4584>
Parent: 5c57aee9_7856d531
UUID: 5c57aee9_f88645d5
Bytes: 601
to clarify ... whether it is decision between shared_ptr and unique_ptr I am agnostic (that seems to have been part of the discussion).

I was concerned about adding dependency on another library in order to get explicit reference counting class (in which case I'd rather stick with shared_ptr until we have more data).

(reading the discussion on smart pointers where they prefer unique pointer over shared pointer, I realized that there may be confusion (by me) which of the options (shared vs. unique, and shared vs. some other shared) we were discussing. Hopefully this helps clarify what I meant.

