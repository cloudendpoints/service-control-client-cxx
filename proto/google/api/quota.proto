syntax = "proto3";

package google.api;

import "google/api/annotations.proto";

option go_package = "google.golang.org/genproto/googleapis/api/serviceconfig;serviceconfig";
option java_multiple_files = true;
option java_outer_classname = "QuotaProto";
option java_package = "com.google.api";
option objc_class_prefix = "GAPI";

// (== page quota ==)
//
// Quota configuration helps to achieve fairness and budgeting in service
// usage.
//
// - Fairness is achieved through the use of short-term quota limits
//   that are usually defined over a time window of several seconds or
//   minutes. When such a limit is applied, for example at the user
//   level, it ensures that no single user will monopolize the service
//   or a given customer's allocated portion of it.
// - Budgeting is achieved through the use of long-term quota limits
//   that are usually defined over a time window of one or more
//   days. These limits help client application developers predict the
//   usage and help budgeting.
//
// Quota enforcement uses a simple token-based algorithm for resource sharing.
//
// The quota configuration structure is as follows:
//
// - `QuotaLimit` defines a single enforceable limit with a specified
//   token amount that can be consumed over a specific duration and
//   applies to a particular entity, like a project or an end user. If
//   the limit applies to a user, each user making the request will
//   get the specified number of tokens to consume. When the tokens
//   run out, the requests from that user will be blocked until the
//   duration elapses and the next duration window starts.
//
// - `QuotaGroup` groups a set of quota limits.
//
// - `QuotaRule` maps a method to a set of quota groups. This allows
//   sharing of quota groups across methods as well as one method
//   consuming tokens from more than one quota group. When a group
//   contains multiple limits, requests to a method consuming tokens
//   from that group must satisfy all the limits in that group.
//
// Example:
//
//     quota:
//       groups:
//       - name: ReadGroup
//         description: Read requests
//         limits:
//         - name: ProjectQps
//           default_limit: 10000
//           duration: 100s
//           limit_by: CLIENT_PROJECT
//
//         - name: UserQps
//           default_limit: 200
//           duration: 100s
//           limit_by: USER
//
//       - name: WriteGroup
//         description: Write requests
//         limits:
//         - name: ProjectQps
//           default_limit: 1000
//           max_limit: 2000
//           duration: 100s
//           limit_by: CLIENT_PROJECT
//
//         - name: UserQps
//           default_limit: 200
//           max_limit: 400
//           duration: 100s
//           limit_by: USER
//
//       rules:
//       - selector: "*"
//         groups:
//         - group: ReadGroup
//       - selector: google.calendar.Calendar.Update
//         groups:
//         - group: WriteGroup
//           cost: 2
//       - selector: google.calendar.Calendar.Delete
//         groups:
//         - group: WriteGroup
//
// Here, the configuration defines two quota groups: ReadGroup and WriteGroup,
// each defining its own per-second and per-second-per-user limits. Note that
// One Platform enforces per-second limits averaged over 100 second window. The
// rules map ReadGroup for all methods, except for Update and Delete.
// These two methods consume from WriteGroup, with Update method consuming at
// twice the rate as Delete method.
//
// Multiple quota groups can be specified for a method. The quota limits in all
// of those groups will be enforced. Example:
//
//     quota:
//       groups:
//       - name: WriteGroup
//         description: Write requests
//         limits:
//         - name: ProjectQps
//           default_limit: 1000
//           max_limit: 1000
//           duration: 100s
//           limit_by: CLIENT_PROJECT
//
//         - name: UserQps
//           default_limit: 200
//           max_limit: 400
//           duration: 100s
//           limit_by: USER
//
//       - name: StorageGroup
//         description: Storage requests
//         limits:
//         - name: StorageQuota
//           default_limit: 1000
//           duration: 0
//           limit_by: USER
//
//       rules:
//       - selector: google.calendar.Calendar.Create
//         groups:
//         - group: StorageGroup
//         - group: WriteGroup
//       - selector: google.calendar.Calendar.Delete
//         groups:
//         - group: StorageGroup
//
// In the above example, the Create and Delete methods manage the user's
// storage space. In addition, Create method uses WriteGroup to manage the
// requests. In this case, requests to Create method need to satisfy all quota
// limits defined in both quota groups.
//
// One can disable quota for selected method(s) identified by the selector by
// setting disable_quota to true. For example,
//
//       rules:
//       - selector: "*"
//         group:
//         - group ReadGroup
//       - selector: google.calendar.Calendar.Select
//         disable_quota: true
//
// (--GOOGLE_EXPERIMENTAL:
//
// CURRENTLY UNDER DEVELOPMENT. DO NOT USE IT UNTIL THIS WARNING IS REMOVED.
//
// The following describes a new quota configuration mechanism we are
// developing.
//
// The quota configuration helps to achieve fair use and protect services from
// over-use and abuse.
//
// The quota configuration works this way:
// - The service configuration defines a set of metrics.
// - For API calls, the quota.metric_rules maps methods to metrics with
//   corresponding costs.
// - The quota.limits defines limits on the metrics, which will be used for
//   quota checks at runtime.
//
// An example quota configuration in yaml format:
//
//    quota:
//      limits:
//      - name: apiReadQpsPerProjectPerUser
//        metric: library.googleapis.com/read_calls
//        unit: "1/min/{project}/{user}" # per-user limit for consumer projects
//        values:
//          STANDARD: 1000
//
//      - name: apiWriteQpsPerProject
//        metric: library.googleapis.com/write_calls
//        unit: "1/min/{project}"  # rate limit for consumer projects
//        values:
//          STANDARD: 10000
//
//      - name: borrowedCountPerOrganization
//        metric: library.googleapis.com/borrowed_count
//        is_precise: true
//        unit: "1/{organization}" # allocation limit for organizations
//        values:
//          LOW: 200
//          STANDARD: 1000
//          HIGH: 10000
//
//      - name: borrowedCountPerOrganizationPerRegion
//        metric: library.googleapis.com/borrowed_count
//        unit: "1/{organization}/{region}"
//        is_precise: true
//        values:
//          LOW: 20
//          STANDARD: 200
//          HIGH: 2000
//          VERY_HIGH: 5000
//          LOW/us-central1: 50
//          STANDARD/us-central1: 500
//          HIGH/us-central1: 4000
//          VERY_HIGH/us-central1: 5000
//
//      # The metric rules bind all methods to the read_calls metric,
//      # except for the UpdateBook and DeleteBook methods. These two methods
//      # are mapped to the write_calls metric, with the UpdateBook method
//      # consuming at twice rate as the DeleteBook method.
//      metric_rules:
//      - selector: "*"
//        metric_costs:
//          library.googleapis.com/read_calls: 1
//      - selector: google.example.library.v1.LibraryService.UpdateBook
//        metric_costs:
//          library.googleapis.com/write_calls: 2
//      - selector: google.example.library.v1.LibraryService.DeleteBook
//        metric_costs:
//          library.googleapis.com/write_calls: 1
//
//  Corresponding Metric definition:
//
//      metrics:
//      - name: library.googleapis.com/read_calls
//        display_name: Read requests
//        metric_kind: DELTA
//        value_type: INT64
//
//      - name: library.googleapis.com/write_calls
//        display_name: Write requests
//        metric_kind: DELTA
//        value_type: INT64
//
//      - name: library.googleapis.com/borrowed_count
//        display_name: Borrowed books
//        metric_kind: DELTA
//        value_type: INT64
//
// --)
message Quota {
  // List of `QuotaGroup` definitions for the service.
  repeated QuotaGroup groups = 1;

  // A list of quota rules that apply to individual API methods and operations.
  //
  // **NOTE:** All service configuration rules follow "last one wins" order.
  repeated QuotaRule rules = 2;

  // List of `QuotaLimit` definitions for the service.
  //
  // CURRENTLY UNDER DEVELOPMENT. DO NOT USE IT UNTIL THIS WARNING IS REMOVED.
  repeated QuotaLimit limits = 3;

  // List of `MetricRule` definitions, each one mapping a selected method to one
  // or more metrics.
  //
  // CURRENTLY UNDER DEVELOPMENT. DO NOT USE IT UNTIL THIS WARNING IS REMOVED.
  repeated MetricRule metric_rules = 4;
}

// Bind API methods to metrics. Binding a method to a metric causes that
// metric's configured quota, billing, and monitoring behaviors to apply to the
// method call.
//
// CURRENTLY UNDER DEVELOPMENT. DO NOT USE IT UNTIL THIS WARNING IS REMOVED.
message MetricRule {
  // Selects the methods to which this rule applies.
  //
  // Refer to [selector][DocumentationRule.selector] for syntax details.
  string selector = 1;

  // Metrics to update when the selected methods are called, and the associated
  // cost applied to each metric.
  //
  // The key of the map is the metric name, and the values are the amount
  // increased for the metric against which the quota limits are defined.
  // The value must not be negative.
  map<string, int64> metric_costs = 2;
}

// `QuotaRule` maps a method to a set of `QuotaGroup`s.
message QuotaRule {
  // Selects methods to which this rule applies.
  //
  // Refer to [selector][DocumentationRule.selector] for syntax details.
  string selector = 1;

  // Quota groups to be used for this method. This supports associating a cost
  // with each quota group.
  repeated QuotaGroupMapping groups = 2;

  // Indicates if quota checking should be enforced. Quota will be disabled for
  // methods without quota rules or with quota rules having this field set to
  // true. When this field is set to true, no quota group mapping is allowed.
  // Deprecated and discontinued: do not use this setting since this is not
  // needed any more.
  bool disable_quota = 3 [deprecated = true];
}

// A quota group mapping.
message QuotaGroupMapping {
  // The `QuotaGroup.name` of the group. Requests for the mapped methods will
  // consume tokens from each of the limits defined in this group.
  string group = 1;

  // Number of tokens to consume for each request. This allows different cost
  // to be associated with different methods that consume from the same quota
  // group. By default, each request will cost one token.
  int32 cost = 2;
}

// `QuotaGroup` defines a set of quota limits to enforce.
message QuotaGroup {
  // Name of this quota group. Must be unique within the service.
  //
  // Quota group name is used as part of the id for quota limits. Once the quota
  // group has been put into use, the name of the quota group should be
  // immutable.
  string name = 1;

  // User-visible description of this quota group.
  string description = 2;

  // Quota limits to be enforced when this quota group is used. A request must
  // satisfy all the limits in a group for it to be permitted.
  repeated QuotaLimit limits = 3;

  // Indicates if the quota limits defined in this quota group apply to
  // consumers who have active billing. Quota limits defined in billable
  // groups will be applied only to consumers who have active billing. The
  // amount of tokens consumed from billable quota group will also be reported
  // for billing. Quota limits defined in non-billable groups will be applied
  // only to consumers who have no active billing.
  bool billable = 4;
}

// `QuotaLimit` defines a specific limit that applies over a specified duration
// for a limit type. There can be at most one limit for a duration and limit
// type combination defined within a `QuotaGroup`.
message QuotaLimit {
  // Name of the quota limit.  Must be unique within the quota group.
  // This name is used to refer to the limit when overriding the limit on
  // a per-project basis.  If a name is not provided, it will be generated
  // from the limit_by and duration fields.
  //
  // The maximum length of the limit name is 64 characters.
  //
  // The name of a limit is used as a unique identifier for this limit.
  // Therefore, once a limit has been put into use, its name should be
  // immutable. You can use the display_name field to provide a user-friendly
  // name for the limit. The display name can be evolved over time without
  // affecting the identity of the limit.
  //
  // (--GOOGLE_EXPERIMENTAL:
  // In the new quota configuration, the name must be provided, and it must be
  // unique within the service. The name can only include alphanumeric
  // characters as well as '-'.
  // --)
  string name = 6;

  // Supported limit types for enforcing quota. Value of this type at runtime
  // will be used to uniquely identify the token pool to consume from.
  enum LimitType {
    // ID of the project owned by the client application developer making the
    // request.
    CLIENT_PROJECT = 0;

    // ID of the end user making the request using the client application.
    USER = 1;
  }

  // Limit type to use for enforcing this quota limit. Each unique value gets
  // the defined number of tokens to consume from. For a quota limit that uses
  // user type, each user making requests through the same client application
  // project will get his/her own pool of tokens to consume, whereas for a limit
  // that uses client project type, all users making requests through the same
  // client application project share a single pool of tokens.
  LimitType limit_by = 1;

  // Optional. User-visible, extended description for this quota limit.
  // Should be used only when more context is needed to understand this limit
  // than provided by the limit's display name (see: `display_name`).
  string description = 2;

  // Default number of tokens that can be consumed during the specified
  // duration. This is the number of tokens assigned when a client
  // application developer activates the service for his/her project.
  //
  // Specifying a value of 0 will block all requests. This can be used if you
  // are provisioning quota to selected consumers and blocking others.
  // Similarly, a value of -1 will indicate an unlimited quota. No other
  // negative values are allowed.
  //
  int64 default_limit = 3;

  // Maximum number of tokens that can be consumed during the specified
  // duration. Client application developers can override the default limit up
  // to this maximum. If specified, this value cannot be set to a value less
  // than the default limit. If not specified, it is set to the default limit.
  //
  // To allow clients to apply overrides with no upper bound, set this to -1,
  // indicating unlimited maximum quota.
  int64 max_limit = 4;

  // Free tier value displayed in the Developers Console for this limit.
  // The free tier is the number of tokens that will be subtracted from the
  // billed amount when billing is enabled.
  // This field can only be set on a limit with duration "1d", in a billable
  // group; it is invalid on any other limit. If this field is not set, it
  // defaults to 0, indicating that there is no free tier for this service.
  // (-- Note that this is not the value used in billing calculations; it is
  // just the value displayed in the console. This value must be kept in sync
  // manually with the corresponding price sheet used by Argentum. --)
  int64 free_tier = 7;

  // Duration of this limit in textual notation. Example: "100s", "24h", "1d".
  // For duration longer than a day, only multiple of days is supported. We
  // support only "100s" and "1d" for now. Additional support will be added in
  // the future. "0" indicates indefinite duration.
  string duration = 5;

  // The name of the metric this quota limit applies to. The quota limits with
  // the same metric will be checked together during runtime. The metric must be
  // defined within the service config.
  //
  // CURRENTLY UNDER DEVELOPMENT. DO NOT USE IT UNTIL THIS WARNING IS REMOVED.
  string metric = 8;

  // Specify the unit of the quota limit. It uses the same syntax as
  // [Metric.unit][]. The supported unit kinds are determined by the quota
  // backend system.
  //
  // The [Google Service Control](https://cloud.google.com/service-control)
  // supports the following unit components:
  // * One of the time intevals:
  //   * "/min"  for quota every minute.
  //   * "/d"  for quota every 24 hours, starting 00:00 US Pacific Time.
  //   * Otherwise the quota won't be reset by time, such as storage limit.
  // * One and only one of the granted containers:
  //   * "/{organization}" quota for an organization.
  //   * "/{project}" quota for a project.
  //   * "/{folder}" quota for a folder.
  //   * "/{resource}" quota for a universal resource.
  // * Zero or more quota segmentation dimension. Not all combos are valid.
  //   * "/{user}" quota for every user GAIA ID or client ip address.
  //     User GAIA ID has precedence over client ip address.
  //   * "/{region}" quota for every region. Not to be used with time intervals.
  //   * Otherwise the resources granted on the target is not segmented.
  //   * "/{zone}" quota for every zone. Not to be used with time intervals.
  //   * Otherwise the resources granted on the target is not segmented.
  //   * "/{resource}" quota for a resource associated with a project or org.
  //
  // Here are some examples:
  // * "1/min/{project}" for quota per minute per project.
  // * "1/min/{user}" for quota per minute per user.
  // * "1/min/{organization}" for quota per minute per organization.
  //
  // Note: the order of unit components is insignificant.
  // The "1" at the beginning is required to follow the metric unit syntax.
  //
  // CURRENTLY UNDER DEVELOPMENT. DO NOT USE IT UNTIL THIS WARNING IS REMOVED.
  string unit = 9;

  // Tiered limit values. Also allows for regional or zone overrides for these
  // values if "/{region}" or "/{zone}" is specified in the unit field.
  //
  // Currently supported tiers from low to high:
  // VERY_LOW, LOW, STANDARD, HIGH, VERY_HIGH
  //
  // To apply different limit values for users according to their tiers, specify
  // the values for the tiers you want to differentiate. For example:
  // {LOW:100, STANDARD:500, HIGH:1000, VERY_HIGH:5000}
  //
  // The limit value for each tier is optional except for the tier STANDARD.
  // The limit value for an unspecified tier falls to the value of its next
  // tier towards tier STANDARD. For the above example, the limit value for tier
  // STANDARD is 500.
  //
  // To apply the same limit value for all users, just specify limit value for
  // tier STANDARD. For example: {STANDARD:500}.
  //
  // To apply a regional overide for a tier, add a map entry with key
  // "<TIER>/<region>", where <region> is a region name. Similarly, for a zone
  // override, add a map entry with key "<TIER>/{zone}".
  // Further, a wildcard can be used at the end of a zone name in order to
  // specify zone level overrides. For example:
  // LOW: 10, STANDARD: 50, HIGH: 100,
  // LOW/us-central1: 20, STANDARD/us-central1: 60, HIGH/us-central1: 200,
  // LOW/us-central1-*: 10, STANDARD/us-central1-*: 20, HIGH/us-central1-*: 80
  //
  // The regional overrides tier set for each region must be the same as
  // the tier set for default limit values. Same rule applies for zone overrides
  // tier as well.
  //
  // CURRENTLY UNDER DEVELOPMENT. DO NOT USE IT UNTIL THIS WARNING IS REMOVED.
  map<string, int64> values = 10;

  // Whether the quota limit needs to be enforced precisely.
  //
  // Note that precise quota limits are more expensive to enforce. Make a quota
  // limit precise only if it is necessary.
  //
  // Precise rate quota is not currently supported. An error will be raised if
  // a rate quota is specified to be precise.
  // Imprecise allocation quota is not currently supported.
  bool is_precise = 11;

  // User-visible display name for this limit.
  // Optional. If not set, the UI will provide a default display name based on
  // the quota configuration. This field can be used to override the default
  // display name generated from the configuration.
  string display_name = 12;

  // Flag intended for pantheon to disable raising the quota on this particular
  // limit. This does not actually prevent quota overrides, it merely disables
  // the default pantheon workflow to request such overrides. See:
  // https://docs.google.com/document/d/1tuNULVrjPDvkEE-xUlcSRS4CxdedoSPBUE_rSSiapFc/edit
  // This flag is set by the service producer.
  // Only pantheon cares about this flag.
  bool is_fixed = 13;

  // Control on the visibility of this quota limit. a comma seperated list of
  // tag such as GOOGLE_INTERNAL, BETA_TESTER
  string visibility_restriction = 14;
}