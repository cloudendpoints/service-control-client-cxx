// TODO: Insert description here. (generated by jaebong)
#include <iostream>

#include "src/quota_aggregator_impl.h"
#include "src/signature.h"

#include "google/protobuf/stubs/logging.h"
#include "google/protobuf/text_format.h"

using std::string;
using ::google::api::MetricDescriptor;
using ::google::api::servicecontrol::v1::Operation;
using ::google::api::servicecontrol::v1::AllocateQuotaRequest;
using ::google::api::servicecontrol::v1::AllocateQuotaResponse;
using ::google::protobuf::util::Status;
using ::google::protobuf::util::error::Code;
using ::google::service_control_client::SimpleCycleTimer;

namespace google {
namespace service_control_client {

void QuotaAggregatorImpl::CacheElem::Aggregate(
    const AllocateQuotaRequest& request, const MetricKindMap* metric_kinds) {
  /*
  if (operation_aggregator_ == NULL) {
    operation_aggregator_.reset(new OperationAggregator(request, metric_kinds));
  } else {
    operation_aggregator_->MergeOperation(request.allocate_operation());
  }
  */
}

AllocateQuotaRequest
QuotaAggregatorImpl::CacheElem::ReturnAllocateQuotaRequestAndClear(
    const string& service_name, const std::string& service_config_id) {
  AllocateQuotaRequest request;
  request.set_service_name(service_name);
  request.set_service_config_id(service_config_id);
  /*
    if (operation_aggregator_ != NULL) {
      *(request.mutable_operation()) =
    operation_aggregator_->ToOperationProto();
      operation_aggregator_ = NULL;
    }
  */
  return request;
}

QuotaAggregatorImpl::QuotaAggregatorImpl(
    const std::string& service_name, const std::string& service_config_id,
    const QuotaAggregationOptions& options,
    std::shared_ptr<MetricKindMap> metric_kinds)
    : service_name_(service_name),
      service_config_id_(service_config_id),
      options_(options),
      metric_kinds_(metric_kinds) {
  // Converts flush_interval_ms to Cycle used by SimpleCycleTimer.
  flush_interval_in_cycle_ =
      options_.flush_interval_ms * SimpleCycleTimer::Frequency() / 1000;

  if (options.num_entries > 0) {
    cache_.reset(new QuotaCache(
        options.num_entries, std::bind(&QuotaAggregatorImpl::OnCacheEntryDelete,
                                       this, std::placeholders::_1)));
    cache_->SetMaxIdleSeconds(options.expiration_ms / 1000.0);
  }
}

QuotaAggregatorImpl::~QuotaAggregatorImpl() {
  SetFlushCallback(NULL);
  FlushAll();
}

// Sets the flush callback function.
// The callback function must be light and fast.  If it needs to make
// a remote call, it must be non-blocking call.
// It should NOT call into this object again from this callback.
// It will cause dead-lock.
void QuotaAggregatorImpl::SetFlushCallback(FlushCallback callback) {
  InternalSetFlushCallback(callback);
}

// If the quota could not be handled by the cache, returns NOT_FOUND,
// caller has to send the request to service control.
// Otherwise, returns OK and cached response.
::google::protobuf::util::Status QuotaAggregatorImpl::Quota(
    const ::google::api::servicecontrol::v1::AllocateQuotaRequest& request,
    ::google::api::servicecontrol::v1::AllocateQuotaResponse* response) {
  if (request.service_name() != service_name_) {
    return Status(Code::INVALID_ARGUMENT,
                  (string("Invalid service name: ") + request.service_name() +
                   string(" Expecting: ") + service_name_));
  }

  if (!request.has_allocate_operation()) {
    return Status(Code::INVALID_ARGUMENT,
                  "allocate operation field is required.");
  }

  string request_signature = GenerateAllocateQuotaRequestSignature(request);

  AllocateQuotaCacheRemovedItemsHandler::StackBuffer stack_buffer(this);
  MutexLock lock(cache_mutex_);
  AllocateQuotaCacheRemovedItemsHandler::StackBuffer::Swapper swapper(
      this, &stack_buffer);

  QuotaCache::ScopedLookup lookup(cache_.get(), request_signature);
  if (!lookup.Found()) {
    // By returning NO_FOUND, caller will send request to server.
    return Status(Code::NOT_FOUND, "");
  }

  CacheElem* elem = lookup.value();

  // If the cached check response has check errors, then we assume the new
  // request should fail as well and return the cached check response.
  // However, after the flush interval, the first check request will be send to
  // the server to refresh the check response. Other check requests still fail
  // with cached check response.
  // If the cached check response is a pass, then we assume the new request
  // should pass as well and return the cached response directly, besides
  // updating the quota info to be the same as requested. The requested tokens
  // are aggregated until flushed.
  // More details can be found in design doc go/simple-chemist-client.
  if (elem->check_response().allocate_errors_size() > 0) {
    if (ShouldFlush(*elem)) {
      // Pretend that we did not find, so we can force it into a check request
      // to the server.
      //
      // Setting last check to now to block more check requests to Chemist.
      elem->set_last_check_time(SimpleCycleTimer::Now());
      // By returning NO_FOUND, caller will send request to server.
      return Status(Code::NOT_FOUND, "");
    } else {
      // Use cached response.
      *response = elem->check_response();
      return Status::OK;
    }
  } else {
    elem->Aggregate(request, metric_kinds_.get());

    if (ShouldFlush(*elem)) {
      if (elem->is_flushing()) {
        GOOGLE_LOG(WARNING) << "Last refresh request was not completed yet.";
      }

      elem->set_is_flushing(true);

      // Setting last check to now to block more check requests to Chemist.
      elem->set_last_check_time(SimpleCycleTimer::Now());

      // By returning NO_FOUND, caller will send request to server.
      return Status(Code::NOT_FOUND, "");
    }

    *response = elem->check_response();
  }
  // TODO(qiwzhang): supports quota
  // ScaleQuotaTokens(request, elem->quota_scale(), response);

  return ::google::protobuf::util::Status::OK;
}

bool QuotaAggregatorImpl::ShouldFlush(const CacheElem& elem) {
  int64_t age = SimpleCycleTimer::Now() - elem.last_check_time();

  // TODO(chengliang): consider accumulated tokens as well. If the
  // accumulated number of tokens is larger than a threshold, we may also
  // decide to send the request.
  //
  // This will prevent sending more RPCs while there is an ongoing one most of
  // the time, except when there is a long RPC that exceeds the flush interval.

  return age >= flush_interval_in_cycle_;
}

// Caches a response from a remote Service Controller AllocateQuota call.
::google::protobuf::util::Status QuotaAggregatorImpl::CacheResponse(
    const ::google::api::servicecontrol::v1::AllocateQuotaRequest& request,
    const ::google::api::servicecontrol::v1::AllocateQuotaResponse& response) {

  AllocateQuotaCacheRemovedItemsHandler::StackBuffer stack_buffer(this);
  MutexLock lock(cache_mutex_);
  AllocateQuotaCacheRemovedItemsHandler::StackBuffer::Swapper swapper(
      this, &stack_buffer);

  if (cache_) {
    string request_signature = GenerateAllocateQuotaRequestSignature(request);
    QuotaCache::ScopedLookup lookup(cache_.get(), request_signature);

    int64_t now = SimpleCycleTimer::Now();

    // TODO(qiwzhang): supports quota
    // int scale = GetQuotaScale(request, response);
    int quota_scale = 0;
    if (lookup.Found()) {
      lookup.value()->set_last_check_time(now);
      lookup.value()->set_quota_response(response);
      lookup.value()->set_quota_scale(quota_scale);
      lookup.value()->set_is_flushing(false);
    } else {
      CacheElem* cache_elem = new CacheElem(response, now, quota_scale);
      cache_->Insert(request_signature, cache_elem, 1);
    }
  }

  return ::google::protobuf::util::Status::OK;
}

// When the next Flush() should be called.
// Returns in ms from now, or -1 for never
int QuotaAggregatorImpl::GetNextFlushInterval() {
  if (!cache_) return -1;
  return options_.expiration_ms;
}

// Invalidates expired allocate quota responses.
// Called at time specified by GetNextFlushInterval().
::google::protobuf::util::Status QuotaAggregatorImpl::Flush() {
  AllocateQuotaCacheRemovedItemsHandler::StackBuffer stack_buffer(this);
  MutexLock lock(cache_mutex_);
  AllocateQuotaCacheRemovedItemsHandler::StackBuffer::Swapper swapper(
      this, &stack_buffer);
  if (cache_) {
    cache_->RemoveExpiredEntries();
  }

  return Status::OK;
}

// Flushes out all cached check responses; clears all cache items.
// Usually called at destructor.
::google::protobuf::util::Status QuotaAggregatorImpl::FlushAll() {
  AllocateQuotaCacheRemovedItemsHandler::StackBuffer stack_buffer(this);
  MutexLock lock(cache_mutex_);
  AllocateQuotaCacheRemovedItemsHandler::StackBuffer::Swapper swapper(
      this, &stack_buffer);

  GOOGLE_LOG(INFO) << "Remove all entries of check aggregator.";
  if (cache_) {
    cache_->RemoveAll();
  }

  return Status::OK;
}

void QuotaAggregatorImpl::OnCacheEntryDelete(CacheElem* elem) {
  if (!elem->HasPendingAllocateQuotaRequest()) {
    delete elem;
    return;
  }

  AllocateQuotaRequest request;
  request = elem->ReturnAllocateQuotaRequestAndClear(service_name_,
                                                     service_config_id_);
  AddRemovedItem(request);
  delete elem;
}

std::unique_ptr<QuotaAggregator> CreateAllocateQuotaAggregator(
    const std::string& service_name, const std::string& service_config_id,
    const QuotaAggregationOptions& options,
    std::shared_ptr<MetricKindMap> metric_kind) {
  return std::unique_ptr<QuotaAggregator>(new QuotaAggregatorImpl(
      service_name, service_config_id, options, metric_kind));
}

}  // namespace service_control_client
}  // namespace google
