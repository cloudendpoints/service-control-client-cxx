// TODO: Insert description here. (generated by jaebong)

#include "src/quota_operation_aggregator.h"

#include <unordered_map>

#include "gmock/gmock.h"
#include "google/protobuf/text_format.h"
#include "google/protobuf/util/message_differencer.h"
#include "gtest/gtest.h"
#include "utils/status_test_util.h"

#include <unistd.h>

using std::string;
using ::google::api::servicecontrol::v1::QuotaOperation;
using ::google::protobuf::TextFormat;
using ::google::protobuf::util::MessageDifferencer;
using ::google::protobuf::util::Status;
using ::google::protobuf::util::error::Code;

namespace google {
namespace service_control_client {
namespace {

const char kOperation1[] = R"(
operation_id: "operationid"
method_name: "methodname"
consumer_id: "consumerid"
quota_metrics {
  metric_name: "metric_first"
  metric_values {
    int64_value: 1
  }
}
quota_metrics {
  metric_name: "metric_second"
  metric_values {
    int64_value: 1
  }
}
quota_mode: NORMAL
)";

const char kOperation2[] = R"(
operation_id: "operationid"
method_name: "methodname"
consumer_id: "consumerid"
quota_metrics {
  metric_name: "metric_first"
  metric_values {
    int64_value: 2
  }
}
quota_metrics {
  metric_name: "metric_second"
  metric_values {
    int64_value: 3
  }
}
quota_mode: NORMAL
)";

const char kOperation3[] = R"(
operation_id: "operationid"
method_name: "methodname"
consumer_id: "consumerid"
quota_mode: NORMAL
)";

}  // namespace

class QuotaOperationAggregatorImplTest : public ::testing::Test {
 public:
  void SetUp() {
    ASSERT_TRUE(TextFormat::ParseFromString(kOperation1, &operation1_));
    ASSERT_TRUE(TextFormat::ParseFromString(kOperation2, &operation2_));
    ASSERT_TRUE(TextFormat::ParseFromString(kOperation3, &operation3_));
  }

  ::google::api::servicecontrol::v1::QuotaOperation operation1_;
  ::google::api::servicecontrol::v1::QuotaOperation operation2_;
  ::google::api::servicecontrol::v1::QuotaOperation operation3_;
};

TEST_F(QuotaOperationAggregatorImplTest, TestInitialization) {
  QuotaOperationAggregator aggregator(operation1_);

  QuotaOperation operation = aggregator.ToOperationProto();
  ASSERT_TRUE(aggregator.is_aggregated());

  std::set<std::pair<std::string, int>> quota_metrics;
  for (auto quota_metric : operation.quota_metrics()) {
    quota_metrics.insert(
        std::make_pair(quota_metric.metric_name(),
                       quota_metric.metric_values(0).int64_value()));
  }

  std::set<std::pair<std::string, int>> expected_costs = {{"metric_first", 1},
                                                          {"metric_second", 1}};
  ASSERT_EQ(quota_metrics, expected_costs);
}

TEST_F(QuotaOperationAggregatorImplTest, TestInitializationNotAggregated) {
  QuotaOperationAggregator aggregator(operation3_);

  QuotaOperation operation = aggregator.ToOperationProto();
  ASSERT_FALSE(aggregator.is_aggregated());
}

TEST_F(QuotaOperationAggregatorImplTest, TestMergeOperation) {
  QuotaOperationAggregator aggregator(operation1_);

  QuotaOperation operation = aggregator.ToOperationProto();
  ASSERT_TRUE(aggregator.is_aggregated());

  std::set<std::pair<std::string, int>> quota_metrics;
  for (auto quota_metric : operation.quota_metrics()) {
    quota_metrics.insert(
        std::make_pair(quota_metric.metric_name(),
                       quota_metric.metric_values(0).int64_value()));
  }

  std::set<std::pair<std::string, int>> expected_costs = {{"metric_first", 1},
                                                          {"metric_second", 1}};
  ASSERT_EQ(quota_metrics, expected_costs);

  aggregator.MergeOperation(operation2_);

  operation = aggregator.ToOperationProto();
  ASSERT_TRUE(aggregator.is_aggregated());

  quota_metrics.clear();
  for (auto quota_metric : operation.quota_metrics()) {
    quota_metrics.insert(
        std::make_pair(quota_metric.metric_name(),
                       quota_metric.metric_values(0).int64_value()));
  }

  expected_costs = {{"metric_first", 3}, {"metric_second", 4}};
  ASSERT_EQ(quota_metrics, expected_costs);
}

TEST_F(QuotaOperationAggregatorImplTest, TestMergeOperationToNullOperation) {
  QuotaOperationAggregator aggregator(operation3_);
  ASSERT_FALSE(aggregator.is_aggregated());

  aggregator.MergeOperation(operation2_);
  ASSERT_TRUE(aggregator.is_aggregated());

  QuotaOperation operation = aggregator.ToOperationProto();

  std::set<std::pair<std::string, int>> quota_metrics;
  for (auto quota_metric : operation.quota_metrics()) {
    quota_metrics.insert(
        std::make_pair(quota_metric.metric_name(),
                       quota_metric.metric_values(0).int64_value()));
  }

  std::set<std::pair<std::string, int>> expected_costs = {{"metric_first", 2},
                                                          {"metric_second", 3}};
  ASSERT_EQ(quota_metrics, expected_costs);
}

TEST_F(QuotaOperationAggregatorImplTest, TestMergeOperationNullOperation) {
  QuotaOperationAggregator aggregator(operation2_);
  ASSERT_TRUE(aggregator.is_aggregated());

  aggregator.MergeOperation(operation3_);
  ASSERT_TRUE(aggregator.is_aggregated());

  QuotaOperation operation = aggregator.ToOperationProto();

  std::set<std::pair<std::string, int>> quota_metrics;
  for (auto quota_metric : operation.quota_metrics()) {
    quota_metrics.insert(
        std::make_pair(quota_metric.metric_name(),
                       quota_metric.metric_values(0).int64_value()));
  }

  std::set<std::pair<std::string, int>> expected_costs = {{"metric_first", 2},
                                                          {"metric_second", 3}};
  ASSERT_EQ(quota_metrics, expected_costs);
}

}  // namespace service_control_client
}  // namespace google
